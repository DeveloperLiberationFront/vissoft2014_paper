@article{Ainsworth2003,
abstract = {Self-explaining is an effective metacognitive strategy that can help learners develop deeper understanding of the material they study. This experiment explored if the format of material (i.e., text or diagrams) influences the self-explanation effect. Twenty subjects were presented with information about the human circulatory system and prompted to self-explain; 10 received this information in text and 10 in diagrams. Results showed that students given diagrams performed significantly better on post-tests than students given text. Diagrams students also generated significantly more self-explanations that text students. Furthermore, the benefits of self-explaining were much greater in the diagrams condition. To discover why diagrams can promote the self-explanation effect, results are interpreted with reference to the multiple differences in the semantic, cognitive and affective properties of the texts and diagrams studied.},
author = {Ainsworth, Shaaron and Loizou, Andrea Th},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ainsworth - 2003 - The effects of self-explaining when learning with text or diagrams.pdf:pdf},
journal = {Cognitive Science},
keywords = {barik\_vissoft,diagram},
mendeley-tags = {barik\_vissoft,diagram},
month = aug,
number = {4},
pages = {669--681},
title = {{The effects of self-explaining when learning with text or diagrams}},
volume = {27},
year = {2003}
}

@inproceedings{Lim2009,
abstract = {Context-aware intelligent systems employ implicit inputs, and make decisions based on complex rules and machine learning models that are rarely clear to users. Such lack of system intelligibility can lead to loss of user trust, satisfaction and acceptance of these systems. However, automatically providing explanations about a system's decision process can help mitigate this problem. In this paper we present results from a controlled study with over 200 participants in which the effectiveness of different types of explanations was examined. Participants were shown examples of a system's operation along with various automatically generated explanations, and then tested on their understanding of the system. We show, for example, that explanations describing why the system behaved a certain way resulted in better understanding and stronger feelings of trust. Explanations describing why the system did not behave a certain way, resulted in lower understanding yet adequate performance. We discuss implications for the use of our findings in real-world context-aware applications.},
author = {Lim, Brian Y. and Dey, Anind K. and Avrahami, Daniel},
booktitle = {CHI '09},
doi = {10.1145/1518701.1519023},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lim, Dey, Avrahami - 2009 - Why and why not explanations improve the intelligibility of context-aware intelligent systems.pdf:pdf},
isbn = {9781605582467},
keywords = {barik\_vissoft,barik\_vlhccdc},
mendeley-tags = {barik\_vissoft,barik\_vlhccdc},
month = apr,
pages = {2119--2129},
title = {{Why and why not explanations improve the intelligibility of context-aware intelligent systems}},
year = {2009}
}

@article{Letovsky1987,
abstract = {This paper reports on an empirical study of the cognitive processes involved in program comprehension. Verbal protocols were gathered from professional programmers as they were engaged in a program-understanding task. Based on analysis of these protocols, several types of interesting cognitive events were identified. These include asking questions and conjecturing facts about the code. We describe these event types and use them to derive a computational model of the programmers' mental processes.},
author = {Letovsky, Stanley},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Letovsky - 1987 - Cognitive processes in program comprehension.pdf:pdf},
journal = {Journal of Systems and Software},
keywords = {call graph,software engineering,software psychology},
mendeley-tags = {call graph,software engineering,software psychology},
number = {4},
pages = {325--339},
title = {Cognitive processes in program comprehension},
volume = {7},
year = {1987}
}
@article{Moody2009a,
abstract = {Visual notations form an integral part of the language of software engineering (SE). Yet historically, SE researchers and notation designers have ignored or undervalued issues of visual representation. In evaluating and comparing notations, details of visual syntax are rarely discussed. In designing notations, the majority of effort is spent on semantics, with graphical conventions largely an afterthought. Typically, no design rationale, scientific or otherwise, is provided for visual representation choices. While SE has developed mature methods for evaluating and designing semantics, it lacks equivalent methods for visual syntax. This paper defines a set of principles for designing cognitively effective visual notations: ones that are optimized for human communication and problem solving. Together these form a design theory, called the Physics of Notations as it focuses on the physical (perceptual) properties of notations rather than their logical (semantic) properties. The principles were synthesized from theory and empirical evidence from a wide range of fields and rest on an explicit theory of how visual notations communicate. They can be used to evaluate, compare, and improve existing visual notations as well as to construct new ones. The paper identifies serious design flaws in some of the leading SE notations, together with practical suggestions for improving them. It also showcases some examples of visual notation design excellence from SE and other fields.},
author = {Moody, D.},
doi = {10.1109/TSE.2009.67},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Moody - 2009 - The “Physics” of Notations Toward a Scientific Basis for Constructing Visual Notations in Software Engineering.pdf:pdf},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Computer industry,Concrete,Design optimization,Flowcharts,Humans,Modeling,Physics,Problem-solving,Software engineering,Unified modeling language,analysis,barikvissoft,communication,concrete syntax.,design flaws,diagrams,physics of notations,visual notations,visual representation,visual syntax,visualization},
mendeley-tags = {barikvissoft},
month = nov,
number = {6},
pages = {756--779},
shorttitle = {Software Engineering, IEEE Transactions on},
title = {{The ``Physics'' of Notations: Toward a Scientific Basis for Constructing Visual Notations in Software Engineering}},
volume = {35},
year = {2009}
}
@article{Traver2010,
abstract = {Programmers often encounter cryptic compiler error messages that are difficult to understand and thus difficult to resolve. Unfortunately, most related disciplines, including compiler technology, have not paid much attention to this important aspect that affects programmers significantly, apparently because it is felt that programmers should adapt to compilers. In this article, however, this problem is studied from the perspective of the discipline of human-computer interaction to gain insight into why compiler errors messages make the work of programmers more difficult, and how this situation can be alleviated. Additionally, because poorly designed error messages affect novice programmers more adversely, the problems faced by computer science students while learning to program are analyzed, and the obstacles originated by compilers are identified. Examples of actual compiler error messages are provided and carefully commented. Finally, some possible measures that can be taken are outlined, and some principles for compiler error message design are included.},
author = {Traver, V. Javier},
doi = {10.1155/2010/602570},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Traver - 2010 - On Compiler Error Messages What They Say and What They Mean.pdf:pdf},
issn = {1687-5893},
journal = {Advances in Human-Computer Interaction},
keywords = {barik\_vlhccdc,bariknier,error message,software engineering},
mendeley-tags = {barik\_vlhccdc,bariknier,error message,software engineering},
pages = {1--26},
title = {{On compiler error messages: What they say and what they mean}},
volume = {2010},
year = {2010}
}
@article{Shneiderman1977,
abstract = {Judging the relative quality of computer programs and a programmer's comprehension of a given program has proven to be a difficult task. Ability to debug, modify, hand simulate execution or respond to questions about the program all have their weaknesses as comprehension metrics. This paper offers experimental evidence which supports the use of memorization/recall tasks as a further basis for judging program quality and programmer comprehension. A syntactic/semantic model of programmer behavior is presented to provide a basis for this hypothesis.},
author = {Shneiderman, B.},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Shneiderman - 1977 - Measuring computer program quality and comprehension.pdf:pdf},
journal = {International Journal of Man-Machine Studies},
keywords = {barikvissoft,cognitive psychology,commenting,memorization,modification,program comprehension,program design,programmer behavior,programming,programming experiments,programming languages,recall,software engineering,structured programming},
mendeley-tags = {barikvissoft,program comprehension,software engineering},
number = {4},
pages = {465--478},
title = {{Measuring computer program quality and comprehension}},
volume = {9},
year = {1977}
}
@article{Ko2005,
abstract = {An essential aspect of programmers’ work is the correctness of their code. This makes current HCI techniques ill-suited to analyze and design the programming systems that programmers use everyday, since these techniques focus more on problems with learnability and efficiency of use, and less on error-proneness. We propose a framework and methodology that focuses specifically on errors by supporting the description and identification of the causes of software errors in terms of chains of cognitive breakdowns. The framework is based on both old and new studies of programming, as well as general research on the mechanisms of human error. Our experiences using the framework and methodology to study the Alice programming system have directly inspired the design of several new programming tools and interfaces. This includes the Whyline debugging interface, which we have shown to reduce debugging time by a factor of 8 and help programmers get 40\% further through their tasks. We discuss the framework's and methodology's implications for programming system design, software engineering, and the psychology of programming.},
author = {Ko, Andrew J. and Myers, Brad A.},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ko, Myers - 2005 - A framework and methodology for studying the causes of software errors in programming systems.pdf:pdf},
journal = {Journal of Visual Languages \& Computing},
keywords = {bariknier},
mendeley-tags = {bariknier},
number = {1},
pages = {41--84},
title = {{A framework and methodology for studying the causes of software errors in programming systems}},
volume = {16},
year = {2005}
}
@article{Green1996,
abstract = {The cognitive dimensions framework is a broad-brush evaluation technique for interactive devices and for non-interactive notations. It sets out a small vocabulary of terms designed to capture the cognitively-relevant aspects of structure, and shows how they can be traded off against each other. The purpose of this paper is to propose the framework as an evaluation technique for visual programming environments. We apply it to two commercially-available dataflow languages (with further examples from other systems) and conclude that it is effective and insightful; other HCI-based evaluation techniques focus on different aspects and would make good complements. Insofar as the examples we used are representative, current VPLs are successful in achieving a good ‘closeness of match’, but designers need to consider the ‘viscosity ’ (resistance to local change) and the ‘secondary notation’ (possibility of conveying extra meaning by choice of layout, colour, etc.).},
author = {Green, T.R.G. and Petre, M.},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Green, Petre - 1996 - Usability Analysis of Visual Programming Environments A ‘Cognitive Dimensions’ Framework.pdf:pdf},
journal = {Journal of Visual Languages \& Computing},
keywords = {barik\_vissoft,bariknier},
mendeley-tags = {barik\_vissoft,bariknier},
number = {2},
pages = {131--174},
title = {{Usability analysis of visual programming environments: A `Cognitive Dimensions' framework}},
volume = {7},
year = {1996}
}
@article{Green1998,
author = {Green, Thomas and Blackwell, Alan},
journal = {BCS HCI Conference},
keywords = {barik\_vissoft},
mendeley-tags = {barik\_vissoft},
number = {October},
title = {{Cognitive dimensions of information artefacts: A tutorial}},
year = {1998}
}
@inproceedings{Nielsen1990,
author = {Nielsen, Jakob and Molich, Rolf},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Nielsen, Molich - 1990 - Heuristic evaluation of user interfaces.pdf:pdf},
keywords = {hci,software engineering,yoonki},
mendeley-tags = {hci,software engineering,yoonki},
pages = {249--256},
series = {CHI '90},
title = {{Heuristic evaluation of user interfaces}},
year = {1990}
}
@inproceedings{Ko2004,
abstract = {Debugging is still among the most common and costly of programming activities. One reason is that current debugging tools do not directly support the inquisitive nature of the activity. Interrogative Debugging is a new debugging paradigm in which programmers can ask why did and even why didn't questions directly about their program's runtime failures. The Whyline is a prototype Interrogative Debugging interface for the Alice programming environment that visualizes answers in terms of runtime events directly relevant to a programmer's question. Comparisons of identical debugging scenarios from user tests with and without the Whyline showed that the Whyline reduced debugging time by nearly a factor of 8, and helped programmers complete 40\% more tasks.},
address = {New York, New York, USA},
author = {Ko, Andrew J. and Myers, Brad A.},
booktitle = {Proceedings of the 2004 conference on Human factors in computing systems - CHI '04},
file = {:C$\backslash$:/Users/tbarik/Desktop/p151-ko.pdf:pdf},
keywords = {Alice,barik\_vissoft,debugging,program slicing,whyline},
mendeley-tags = {barik\_vissoft,whyline},
month = apr,
pages = {151--158},
publisher = {ACM Press},
title = {{Designing the whyline}},
year = {2004}
}
@inproceedings{Hartmann2010,
abstract = {Interpreting compiler errors and exception messages is challenging for novice programmers. Presenting examples of how other programmers have corrected similar errors may help novices understand and correct such errors. This paper introduces HelpMeOut, a social recommender system that aids the debugging of error messages by suggesting solutions that peers have applied in the past. HelpMeOut comprises IDE instrumentation to collect examples of code changes that fix errors; a central database that stores fix reports from many users; and a suggestion interface that, given an error, queries the database for a list of relevant fixes and presents these to the programmer. We report on implementations of this architecture for two programming languages. An evaluation with novice programmers found that the technique can suggest useful fixes for 47\% of errors after 39 person-hours of programming in an instrumented environment.},
author = {Hartmann, Bj\"{o}rn and MacDougall, Daniel and Brandt, Joel and Klemmer, Scott R.},
booktitle = {CHI '10},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hartmann et al. - 2010 - What would other programmers do.pdf:pdf},
isbn = {9781605589299},
keywords = {barik\_vissoft,bariknier,debugging,error message,recommender systems,software engineering},
mendeley-tags = {barik\_vissoft,bariknier,error message,software engineering},
month = apr,
pages = {1019--1028},
title = {{What would other programmers do}},
year = {2010}
}
@article{Jeffery2003,
abstract = {LR parser generators are powerful and well-understood, but the parsers they generate are not suited to provide good error messages. Many compilers incur extensive modifications to the source grammar to produce useful syntax error messages. Interpreting the parse state (and input token) at the time of error is a nonintrusive alternative that does not entangle the error recovery mechanism in error message production. Unfortunately, every change to the grammar may significantly alter the mapping from parse states to diagnostic messages, creating a maintenance problem.Merr is a tool that allows a compiler writer to associate diagnostic messages with syntax errors by example, avoiding the need to add error productions to the grammar or interpret integer parse states. From a specification of errors and messages, Merr runs the compiler on each example error to obtain the relevant parse state and input token, and generates a yyerror() function that maps parse states and input tokens to diagnostic messages. Merr enables useful syntax error messages in LR-based compilers in a manner that is robust in the presence of grammar changes.},
author = {Jeffery, Clinton L.},
file = {:C$\backslash$:/Users/tbarik/Desktop/p631-l\_jeffery.pdf:pdf},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {LR parsers,Syntax error messages,barik\_vissoft},
mendeley-tags = {barik\_vissoft},
month = sep,
number = {5},
pages = {631--640},
title = {{Generating LR syntax error messages from examples}},
volume = {25},
year = {2003}
},
@inproceedings{Nienaltowski2008,
abstract = {Novices find it difficult to understand and use compiler error messages. It is useful to refine this observation and study the effect of different message styles on how well and quickly students identify errors in programs. For example, does an increased level of detail simplify the understanding of errors and their correction? We analyzed messages produced by a number of compilers for five programming languages, and grouped them into three style categories from their level of detail and presentation format, and correlated the level of experience and error type with performance and speed of response. The study involved two groups of students taking an introductory programming course at two different institutions; they used messages in these three styles to debug erroneous code. The results indicate that more detailed messages do not necessarily simplify the understanding of errors but that it matters more where information is placed and how it is structured.},
author = {Nienaltowski, Marie-H\'{e}l\`{e}ne and Pedroni, Michela and Meyer, Bertrand},
booktitle = {SIGCSE '08},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Nienaltowski, Pedroni, Meyer - 2008 - Compiler error messages(2).pdf:pdf},
keywords = {bariknier,compiler error messages,error message,novice programmers,software engineering},
mendeley-tags = {bariknier,error message,software engineering},
month = feb,
pages = {168--172},
title = {{Compiler error messages: What can help novices?}},
year = {2008}
}
@article{Kantorowitz1986,
abstract = {Many current compilers produce in some situations wrong error messages that mislead the user and harm his confidence in the system. It is demonstrated that a reliable and efficient syntax error handling system may be produced automatically by a compiler generator from the BNF specification of the language, and without any effort by the language implementor. This result is achieved in three ways: (a) Some errors may not be diagnosed without knowledge of the intentions of the programmer. Some compilers employ a sophisticated analysis that attempts to capture these intentions, but which is not always successful. Such an elaborate analysis is not employed here, and instead a list of all the legal corrections is displayed, so that the programmer may readily select the right one. (b) The recovery symbols are selected by a ‘careful’ algorithm resulting in a high probability for correct error recovery. (c) The ‘honest’ error messages show also the parts of the code which could not be analysed correctly because of errors, and where more errors may exist. Efficiency is achieved by computing the recovery sets once and for all at compiler generation time, so that a fast error recovery at program compilation time is achieved. Experiments with erroneous programs suggest that the method compares well with the best compilers that we have seen, and is specially good at the avoidance of wrong error messages.},
author = {Kantorowitz, E. and Laor, H.},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kantorowitz, Laor - 1986 - Automatic generation of useful syntax error messages.pdf:pdf},
issn = {00380644},
journal = {Software: Practice and Experience},
keywords = {automatic,barik\_vissoft,compiler,error message,software engineering,useful},
mendeley-tags = {automatic,barik\_vissoft,compiler,error message,software engineering,useful},
month = jul,
number = {7},
pages = {627--640},
title = {{Automatic generation of useful syntax error messages}},
volume = {16},
year = {1986}
}
@article{Boustani2011,
abstract = {Since version 1.5, generics (parametric polymorphism) are part of the Java language. However, the combination of parametric polymorphism and inclusion polymorphism is complicated, particularly so for Generic Java. Indeed, the main Java compilers, Eclipse’s ejc and Sun’s javac, do not even accept the same set of programs. Moreover, experience with these compilers shows that the error messages provided by them leave more than a little to be desired. To alleviate the latter problem, we describe how to adapt the type inference process of Java to obtain better error diagnostics for generic method invocations. Although the extension by itself already helps to improve type error messages to some extent, another major advantage of the new type inference process is that it also paves the way for further heuristics can provide additional diagnostic information. The extension has been implemented into the JastAdd Extensible Java Compiler.},
annote = {This is a compiler-based approach.},
author = {Boustani, Nabil and Hage, Jurriaan},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Boustani, Hage - 2011 - Improving type error messages for generic Java.pdf:pdf},
issn = {1388-3690},
journal = {Higher-Order and Symbolic Computation},
keywords = {error message,java},
mendeley-tags = {error message,java},
month = jun,
number = {1-2},
pages = {3--39},
title = {{Improving type error messages for generic Java}},
volume = {24},
year = {2011}
}
@inproceedings{Campbell2014,
abstract = {A frustrating aspect of software development is that compiler error messages often fail to locate the actual cause of a syntax error. An errant semicolon or brace can result in many errors reported throughout the file. We seek to find the actual source of these syntax errors by relying on the consistency of software: valid source code is usually repetitive and unsurprising. We exploit this consistency by constructing a simple N-gram language model of lexed source code tokens. We implemented an automatic Java syntax-error locator using the corpus of the project itself and evaluated its performance on mutated source code from several projects. Our tool, trained on the past versions of a project, can effectively augment the syntax error locations produced by the native compiler. Thus we provide a methodology and tool that exploits the naturalness of software source code to detect syntax errors alongside the parser.},
author = {Campbell, Joshua Charles and Hindle, Abram and Amaral, Jos\'{e} Nelson},
booktitle = {MSR '14},
keywords = {NLP,barik\_vissoft,error location,language,n-grams,naturalness,syntax},
mendeley-tags = {barik\_vissoft},
month = may,
pages = {252--261},
title = {{Syntax errors just aren't natural: Improving error reporting with language models}},
year = {2014}
}

@inproceedings{Parnin2011,
abstract = {Some of the most fascinating feats of cognition are never witnessed or heard by others, yet they occur daily in the minds of software developers practicing their craft. Researchers have desperately tried to glimpse inside, but with limited tools, the view into a developer's internal mental processes has been dim. One available tool, so far overlooked but widely used, has demonstrated the ability to measure the physiological correlates of cognition. When people perform complex tasks, sub-vocal utterances (electrical signals sent to the tongue, lips, or vocal cords) can be detected. This phenomenon has long intrigued researchers, some likening sub-vocal signals to the conduits of our thoughts. Recently, researchers have even been able to decode these signals into words. In this paper, we explore the feasibility of using this approach and report our early results and experiences in recording electromyogram (EMG) signals of software developers performing programming tasks. We believe, these techniques can shed light into the cognitive processes of developers and may even provide novel interactions in future programming environments.},
author = {Parnin, Chris},
booktitle = {ICPC '11},
file = {:C$\backslash$:/Users/tbarik/Desktop/05970156.pdf:pdf},
keywords = {Cognition,EMG signal,Electromyography,Muscles,Programming profession,Speech,Tongue,barik\_vissoft,electrical signal,electromyogram signal,medical signal processing,software developer,subvocal utterance,subvocalization,task assessment},
mendeley-tags = {barik\_vissoft},
month = jun,
pages = {197--200},
shorttitle = {Program Comprehension (ICPC), 2011 IEEE 19th Inter},
title = {{Subvocalization - Toward hearing the inner thoughts of developers}},
year = {2011}
}

@inproceedings{Roberts2001,
abstract = {This paper describes the implementation of MiniJava, a teaching-oriented programming language closely based on the Java language developed by Sun Microsystems [6]. The core of the MiniJava environment is a restricted subset of the standard Java release and is designed to reduce the intimidation factor introductory students experience when they encounter a system as large as the Java environment. The paper outlines the particular restrictions and extensions that define MiniJava along with pedagogical justifications for each.},
author = {Roberts, Eric},
booktitle = {SIGCSE '01},
file = {:C$\backslash$:/Users/tbarik/Desktop/p1-roberts.pdf:pdf},
isbn = {1-58113-329-4},
issn = {00978418},
keywords = {java,vissoft2014},
mendeley-tags = {java,vissoft2014},
month = mar,
number = {1},
pages = {1--5},
title = {{An overview of MiniJava}},
volume = {33},
year = {2001}
}

@inproceedings{Denny2014,
author = {Denny, Paul and Luxton-Reilly, Andrew and Carpenter, Dave},
booktitle = {ITiCSE '14},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Denny, Luxton-Reilly, Carpenter - 2014 - Enhancing syntax error messages appears ineffectual.pdf:pdf},
isbn = {9781450328333},
keywords = {debugging,error messages,errors,feedback,novice,programming,syntax error},
mendeley-tags = {error messages},
month = jun,
pages = {273--278},
title = {{Enhancing syntax error messages appears ineffectual}},
year = {2014}
}

@inproceedings{Chen2014,
author = {Chen, Sheng and Erwig, Martin and Smeltzer, Karl},
booktitle = {VL/HCC '14},
pages = {145--152},
title = {{Let's hear both sides: On combining type-error reporting tools}},
year = {2014}
}
